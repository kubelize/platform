apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: vault
  namespace: argocd
spec:
  project: default
  destination:
    server: https://kubernetes.default.svc
    namespace: "vault-{{ .environment.stage }}"
  source:
    repoURL: https://helm.releases.hashicorp.com
    chart: vault
    targetRevision: 0.32.0
    helm:
      releaseName: vault
      valuesObject:
        global:
          tlsDisable: false

        injector:
          # Configures the port the injector should listen on
          port: 8080

          # If multiple replicas are specified, by default a leader will be determined
          # so that only one injector attempts to create TLS certificates.
          leaderElector:
            enabled: true

          # If true, will enable a node exporter metrics endpoint at /metrics.
          metrics:
            enabled: false

          # image sets the repo and tag of the vault-k8s image to use for the injector.
          image:
            repository: "hashicorp/vault-k8s"
            tag: "1.7.2"
            pullPolicy: IfNotPresent

          # agentImage sets the repo and tag of the Vault image to use for the Vault Agent
          # containers.  This should be set to the official Vault image.  Vault 1.3.1+ is
          # required.
          agentImage:
            repository: "hashicorp/vault"
            tag: "1.21.2"

          # The default values for the injected Vault Agent containers.
          agentDefaults:
            # For more information on configuring resources, see the K8s documentation:
            # https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            cpuLimit: "500m"
            cpuRequest: "250m"
            memLimit: "128Mi"
            memRequest: "64Mi"
            # ephemeralLimit: "128Mi"
            # ephemeralRequest: "64Mi"
            
          # Mount Path of the Vault Kubernetes Auth Method.
          authPath: "auth/kubernetes"

          # Configures the log verbosity of the injector.
          # Supported log levels include: trace, debug, info, warn, error
          logLevel: "info"

          # Configures all Vault Agent sidecars to revoke their token when shutting down
          revokeOnShutdown: false

          webhook:
            # Configures failurePolicy of the webhook. The "unspecified" default behaviour depends on the
            # API Version of the WebHook.
            # To block pod creation while the webhook is unavailable, set the policy to `Fail` below.
            # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#failure-policy
            #
            failurePolicy: Ignore

            # matchPolicy specifies the approach to accepting changes based on the rules of
            # the MutatingWebhookConfiguration.
            # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-matchpolicy
            # for more details.
            #
            matchPolicy: Exact

            # timeoutSeconds is the amount of seconds before the webhook request will be ignored
            # or fails.
            # If it is ignored or fails depends on the failurePolicy
            # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#timeouts
            # for more details.
            #
            timeoutSeconds: 30

            # namespaceSelector is the selector for restricting the webhook to only
            # specific namespaces.
            # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-namespaceselector
            # for more details.
            # Example:
            # namespaceSelector:
            #    matchLabels:
            #      sidecar-injector: enabled
            namespaceSelector: {}

            # objectSelector is the selector for restricting the webhook to only
            # specific labels.
            # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-objectselector
            # for more details.
            # Example:
            # objectSelector:
            #    matchLabels:
            #      vault-sidecar-injector: enabled
            objectSelector: |
              matchExpressions:
              - key: app.kubernetes.io/name
                operator: NotIn
                values:
                - vault-agent-injector

            # Extra annotations to attach to the webhook
            annotations: {}

          # Deprecated: please use 'webhook.failurePolicy' instead
          # Configures failurePolicy of the webhook. The "unspecified" default behaviour depends on the
          # API Version of the WebHook.
          # To block pod creation while webhook is unavailable, set the policy to `Fail` below.
          # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#failure-policy
          #
          failurePolicy: Ignore

          # Deprecated: please use 'webhook.namespaceSelector' instead
          # namespaceSelector is the selector for restricting the webhook to only
          # specific namespaces.
          # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-namespaceselector
          # for more details.
          # Example:
          # namespaceSelector:
          #    matchLabels:
          #      sidecar-injector: enabled
          namespaceSelector: {}

          # Deprecated: please use 'webhook.objectSelector' instead
          # objectSelector is the selector for restricting the webhook to only
          # specific labels.
          # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-objectselector
          # for more details.
          # Example:
          # objectSelector:
          #    matchLabels:
          #      vault-sidecar-injector: enabled
          objectSelector: {}

          # Deprecated: please use 'webhook.annotations' instead
          # Extra annotations to attach to the webhook
          webhookAnnotations: {}

          certs:
            # secretName is the name of the secret that has the TLS certificate and
            # private key to serve the injector webhook. If this is null, then the
            # injector will default to its automatic management mode that will assign
            # a service account to the injector to generate its own certificates.
            secretName: vault-agent-injector-tls

            # caBundle is a base64-encoded PEM-encoded certificate bundle for the CA
            # that signed the TLS certificate that the webhook serves. This must be set
            # if secretName is non-null unless an external service like cert-manager is
            # keeping the caBundle updated.
            caBundle: ""

            # certName and keyName are the names of the files within the secret for
            # the TLS cert and private key, respectively. These have reasonable
            # defaults but can be customized if necessary.
            certName: tls.crt
            keyName: tls.key

        server:
          # If true, or "-" with global.enabled true, Vault server will be installed.
          # See vault.mode in _helpers.tpl for implementation details.
          enabled: "-"

          replicas: 3

          extraVolumes:
            - name: vault-server-tls
              type: secret
              path: /vault/tls

          ha:
            enabled: true
            raft:
              enabled: true
              setNodeId: true
              config: |
                ui = true
                
                # Single listener handles both API and cluster traffic
                # - Port 8200: API/UI access (no client certs requested)
                # - Port 8201: Cluster traffic (Raft handles mTLS via retry_join certs)
                listener "tcp" {
                  address = "[::]:8200"
                  cluster_address = "[::]:8201"
                  tls_disable = 0
                  tls_cert_file = "/vault/tls/vault-server-tls/tls.crt"
                  tls_key_file  = "/vault/tls/vault-server-tls/tls.key"
                  # Do NOT set tls_client_ca_file - would make listener request client certs
                  # Raft mTLS uses leader_ca_cert_file in retry_join instead
                }

                # Make sure Vault advertises the right addresses
                api_addr     = "https://vault-active.vault-{{ .environment.stage }}.svc.cluster.local:8200"
                cluster_addr = "https://$(HOSTNAME).vault-internal.vault-{{ .environment.stage }}.svc.cluster.local:8201"

                storage "raft" {
                  path = "/vault/data"
                  retry_join {
                    auto_join               = "provider=k8s label_selector=\"app.kubernetes.io/name=vault,component=server\" namespace=\"vault-{{ .environment.stage }}\""
                    auto_join_scheme        = "https"
                    auto_join_port          = 8200
                    leader_tls_servername   = "vault-active.vault-{{ .environment.stage }}.svc.cluster.local"
                    leader_ca_cert_file     = "/vault/tls/vault-server-tls/ca.crt"
                    leader_client_cert_file = "/vault/tls/vault-server-tls/tls.crt"
                    leader_client_key_file  = "/vault/tls/vault-server-tls/tls.key"
                  }

                  autopilot {
                    server_stabilization_time          = "10s"
                    last_contact_threshold             = "10s"
                    min_quorum                         = 3
                    cleanup_dead_servers               = "true"
                    dead_server_last_contact_threshold = "10m"
                    max_trailing_logs                  = 10000
                    disable_upgrade_migration          = "false"
                  }
                }

                service_registration "kubernetes" {}


          affinity:
            nodeAffinity:
              requiredDuringSchedulingIgnoredDuringExecution:
                nodeSelectorTerms:
                  - matchExpressions:
                      - key: topology.kubernetes.io/zone
                        operator: In
                        values:
                          - pve-hana
                          - pve-sora
                          - pve-mizu

          topologySpreadConstraints:
            - maxSkew: 1
              topologyKey: topology.kubernetes.io/zone
              whenUnsatisfiable: DoNotSchedule
              labelSelector:
                matchLabels:
                  app.kubernetes.io/name: vault
                  app.kubernetes.io/instance: vault
                  component: server

          podDisruptionBudget:
            maxUnavailable: 1

          image:
            repository: "hashicorp/vault"
            tag: "1.21.2"
            # Overrides the default Image Pull Policy
            pullPolicy: IfNotPresent

          extraEnvironmentVars:
            VAULT_CACERT: /vault/tls/vault-server-tls/ca.crt

          # Configure the Update Strategy Type for the StatefulSet
          # See https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
          updateStrategyType: "OnDelete"


         
